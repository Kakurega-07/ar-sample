<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>å¯Œå£«å±±AR - ãƒã‚¤ã‚ºãƒ»ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³æ”¹å–„ç‰ˆ</title>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
<script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>

<script src="https://raw.githack.com/donmccurdy/aframe-extras/master/src/misc/aframe-extras-misc.js"></script>

<style>
  #info {
    position: fixed;
    top: 10px;
    left: 10px;
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 15px;
    font-family: sans-serif;
    font-size: 14px;
    z-index: 9999;
    border-radius: 5px;
    max-width: 80%;
  }
</style>
</head>
<body style="margin: 0; overflow: hidden;">

<div id="info">
  ğŸ—» å¯Œå£«å±±AR<br>
  ğŸ“ ä½ç½®æƒ…å ±å–å¾—ä¸­...
</div>

<a-scene 
    id="ar-scene"
    vr-mode-ui="enabled: false" 
    renderer="logarithmicDepthBuffer: true"
    arjs='sourceType: webcam; 
          sourceWidth:1280; sourceHeight:960; 
          displayWidth: 1280; displayHeight: 960;
          debugUIEnabled: false;' 
    device-orientation-permission-ui 
    loading-screen="enabled: false"
    embedded>
    
    <a-assets>
        <img id="rock-texture" src="https://cdn.glitch.global/11f0165b-63a2-4a00-ab64-44b20a34891a/rock-texture.jpg?v=1678887467366">
    </a-assets>
    
    <a-entity light="type: ambient; color: #BBB; intensity: 0.8"></a-entity>
    <a-entity light="type: directional; color: #FFF; intensity: 0.6" position="-0.5 1 1"></a-entity>

    <a-camera 
        id="camera"
        look-controls="enabled: true; magicWindowTrackingEnabled: true;"
        position="0 0 0">
    </a-camera>
    
    <a-entity id="fujisan-ar-container" position="0 0 0">
        <a-entity
            id="fuji-realistic-model"
            
            fuji-mountain-generator
            
            material="shader: fuji-shader; 
                      snowColor: #FFFFFF; 
                      rockColor: #5C4B4B; 
                      snowHeight: 3.5; 
                      baseTexture: #rock-texture;
                      fog: 0.3"
            
            position="0 0 -30" rotation="0 0 0"
            scale="1 1 1">
            
            <a-text value="FUJI-SAN" 
                    position="0 6 0" 
                    align="center" 
                    color="#E54C3C" 
                    scale="5 5 5">
            </a-text>
            
        </a-entity>
    </a-entity>
    
</a-scene>

<script>

// --- 1. ã‚«ã‚¹ã‚¿ãƒ ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼: é«˜ã•(Yè»¸)ã«åŸºã¥ã„ã¦è‰²ã‚’ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã•ã›ã‚‹ ---
AFRAME.registerShader('fuji-shader', {
  schema: {
    snowColor: { type: 'color', is: 'uniform', default: '#FFFFFF' },
    rockColor: { type: 'color', is: 'uniform', default: '#5C4B4B' },
    snowHeight: { type: 'number', is: 'uniform', default: 3.5 },
    baseTexture: { type: 'map', is: 'uniform' },
    fog: { type: 'number', is: 'uniform', default: 0.1 }
  },
  
  vertexShader: `
    varying vec3 vWorldPosition;
    varying vec2 vUv;
    
    void main() {
      vUv = uv;
      vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
      vWorldPosition = worldPosition.xyz;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  
  fragmentShader: `
    uniform vec3 snowColor;
    uniform vec3 rockColor;
    uniform float snowHeight;
    uniform sampler2D baseTexture;
    uniform float fog;
    
    varying vec3 vWorldPosition;
    varying vec2 vUv;
    
    void main() {
      // Yåº§æ¨™ã«åŸºã¥ã„ã¦ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¨ˆç®— (0.0 ã‹ã‚‰ 1.0 ã®ãƒ–ãƒ¬ãƒ³ãƒ‰ä¿‚æ•°)
      float blendFactor = smoothstep(snowHeight - 0.5, snowHeight + 0.5, vWorldPosition.y); 
      
      // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
      vec4 texColor = texture2D(baseTexture, vUv * 4.0); // 4å€ç¹°ã‚Šè¿”ã—
      
      // é›ªã®è‰²ã¨å²©ã®è‰²ã‚’ãƒ–ãƒ¬ãƒ³ãƒ‰
      // blendFactor=0.0 (ä½ã„ä½ç½®) -> rockColor, blendFactor=1.0 (é«˜ã„ä½ç½®) -> snowColor
      vec3 finalColor = mix(rockColor, snowColor, blendFactor);
      
      // å²©ã®è‰²ã«ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’æ··ãœã‚‹ (é›ªã®éƒ¨åˆ†ã¯ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®å½±éŸ¿ã‚’å°ã•ãã™ã‚‹)
      finalColor = mix(finalColor, texColor.rgb, 0.5 * (1.0 - blendFactor));
      
      // è·é›¢ã«åŸºã¥ããƒ•ã‚©ã‚°ï¼ˆé ãã®ãƒ¢ãƒ‡ãƒ«ãŒã‹ã™ã‚€åŠ¹æœï¼‰
      float distance = length(vWorldPosition.xyz);
      float alpha = 1.0 - smoothstep(0.0, fog * 100.0, distance); // 100må…ˆã‹ã‚‰ãƒ•ã‚©ã‚°ãŒã‹ã‹ã‚‹ã‚ˆã†ã«èª¿æ•´
      
      gl_FragColor = vec4(finalColor, 1.0);
    }
  `
});


// --- 2. ã‚«ã‚¹ã‚¿ãƒ ã‚¸ã‚ªãƒ¡ãƒˆãƒª: ãƒ‘ãƒ¼ãƒªãƒ³ãƒã‚¤ã‚ºã§å††éŒã«èµ·ä¼ã‚’ç”Ÿæˆ ---
AFRAME.registerComponent('fuji-mountain-generator', {
  init: function () {
    const el = this.el;
    const geometry = new THREE.ConeGeometry( 4, 5, 64, 10 ); // åŠå¾„4ã€é«˜ã•5ã€åˆ†å‰²æ•°64x10
    const noise = new THREE.ImprovedNoise();
    const noiseScale = 0.5; // ãƒã‚¤ã‚ºã®ã‚¹ã‚±ãƒ¼ãƒ«

    // å„é ‚ç‚¹ã‚’ãƒã‚¤ã‚ºã«åŸºã¥ã„ã¦ãƒ©ãƒ³ãƒ€ãƒ ã«ãšã‚‰ã™
    for (let i = 0; i < geometry.vertices.length; i++) {
      const vertex = geometry.vertices[i];
      
      // é ‚ç‚¹ã®XYZåº§æ¨™ã«åŸºã¥ã„ã¦ãƒã‚¤ã‚ºã‚’ç”Ÿæˆ
      const n = noise.noise(vertex.x * noiseScale, vertex.y * noiseScale, vertex.z * noiseScale);
      
      // ãƒã‚¤ã‚ºã‚’é©ç”¨ (é ‚ç‚¹ã®æ³•ç·šæ–¹å‘ã«ã‚ãšã‹ã«ãšã‚‰ã™ã“ã¨ã§èµ·ä¼ã‚’ä½œã‚‹)
      // é ‚ç‚¹æ³•ç·šã‚’å–å¾—
      const normal = vertex.clone().normalize();
      
      // ãƒã‚¤ã‚ºã®é‡ (æœ€å¤§0.2mã®èµ·ä¼)
      const displacement = n * 0.2 * (5 - vertex.y) / 5; // é«˜ã•ãŒé«˜ã„ã»ã©ãƒã‚¤ã‚ºã‚’æŠ‘ãˆã‚‹
      
      vertex.add(normal.multiplyScalar(displacement));
    }

    geometry.verticesNeedUpdate = true;
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();
    
    // ç”Ÿæˆã—ãŸã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚’A-Frameã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã«é©ç”¨
    el.setAttribute('geometry', {
      buffer: true,
      primitive: 'cone',
      skipCache: true, // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¦å†ç”Ÿæˆå¯èƒ½ã«ã™ã‚‹
      'radius-bottom': 4,
      'radius-top': 0.1,
      height: 5,
      segmentsRadial: 64,
      segmentsHeight: 10
    });
    el.object3D.children[0].geometry = geometry;
  }
});


const infoDiv = document.getElementById('info');
const fujisanContainer = document.getElementById('fujisan-ar-container');
const fujiModel = document.getElementById('fuji-realistic-model');

// å¯Œå£«å±±ã®ç¾å®Ÿã®åº§æ¨™
const fujiLat = 35.360556; 
const fujiLon = 138.727778; 

let userLat = null; 
let userLon = null; 

// --- ã‚¸ã‚ªãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³è¨ˆç®—é–¢æ•° (ç¶­æŒ) ---
const R = 6371; 
function toRad(degrees) { return degrees * Math.PI / 180; }

function calcDistance(lat1, lon1, lat2, lon2) { 
    const dLat = toRad(lat2 - lat1); 
    const dLon = toRad(lon2 - lon1); 
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) + 
              Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2) * Math.sin(dLon/2); 
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
    return R * c; 
} 

function calcBearing(lat1, lon1, lat2, lon2) { 
    const dLon = toRad(lon2 - lon1); 
    const y = Math.sin(dLon) * Math.cos(toRad(lat2)); 
    const x = Math.cos(toRad(lat1)) * Math.sin(toRad(lat2)) - 
              Math.sin(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.cos(dLon); 
    const bearing = Math.atan2(y, x) * 180 / Math.PI; 
    return (bearing + 360) % 360; 
} 

function bearingToJapanese(bearing) { 
    const directions = ['åŒ—', 'åŒ—åŒ—æ±', 'åŒ—æ±', 'æ±åŒ—æ±', 'æ±', 'æ±å—æ±', 'å—æ±', 'å—å—æ±', 
                        'å—', 'å—å—è¥¿', 'å—è¥¿', 'è¥¿å—è¥¿', 'è¥¿', 'è¥¿åŒ—è¥¿', 'åŒ—è¥¿', 'åŒ—åŒ—è¥¿']; 
    const index = Math.round(bearing / 22.5) % 16; 
    return directions[index]; 
} 

function bearingToPosition(bearing, distance) { 
    const rad = toRad(bearing); 
    const x = Math.sin(rad) * distance;  
    const z = -Math.cos(rad) * distance; 
    return { x, z }; 
} 

// --- å¯Œå£«å±±ã¨ã‚³ãƒ³ãƒ‘ã‚¹ã®ä½ç½®ã‚’æ›´æ–°ï¼ˆã‚¸ã‚ªãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ARã®è‚ï¼‰ ---
function updatePositions() { 
    if (userLat === null || userLon === null) {
        infoDiv.innerHTML = `
            ğŸ—» <strong>å¯Œå£«å±±AR</strong><br>
            ğŸ“ ä½ç½®æƒ…å ±å–å¾—ä¸­...<br><br>
            âš ï¸ **ä½ç½®æƒ…å ±ãŒå–å¾—ã§ãã¾ã›ã‚“ã€‚** ãƒ–ãƒ©ã‚¦ã‚¶ã®è¨­å®šã‚„ãƒ‡ãƒã‚¤ã‚¹ã®GPSã‚’æœ‰åŠ¹ã«ã—ã¦ãã ã•ã„ã€‚
        `;
        fujisanContainer.setAttribute('visible', false);
        return; 
    }
    
    fujisanContainer.setAttribute('visible', true);

    const bearing = calcBearing(userLat, userLon, fujiLat, fujiLon); 
    const distance = calcDistance(userLat, userLon, fujiLat, fujiLon); 
    const direction = bearingToJapanese(bearing); 
    
    const AR_DISTANCE = 30; // ARç©ºé–“ä¸Šã®ãƒ¢ãƒ‡ãƒ«é…ç½®è·é›¢
    const fujiPos = bearingToPosition(bearing, AR_DISTANCE); 
    
    // ãƒ¢ãƒ‡ãƒ«ã‚³ãƒ³ãƒ†ãƒŠã®ä½ç½®ã‚’æ›´æ–°ã—ã€æ­£ã—ã„æ–¹è§’ã«è¡¨ç¤º
    if (fujisanContainer) {
        fujisanContainer.setAttribute('position', `${fujiPos.x} 0 ${fujiPos.z}`);
        
        // ãƒ¢ãƒ‡ãƒ«ã®ã‚µã‚¤ã‚ºã‚’è·é›¢ã«å¿œã˜ã¦èª¿æ•´
        const scaleFactor = Math.min(1.0, distance / 500); // 500kmã§æœ€å¤§ã‚¹ã‚±ãƒ¼ãƒ«ã«ãªã‚‹ã‚ˆã†ã«èª¿æ•´
        const minScale = 0.5;
        const finalScale = Math.max(minScale, scaleFactor);
        
        // ã‚³ãƒ³ãƒ†ãƒŠå†…ã®ãƒ¢ãƒ‡ãƒ«ã®ã‚¹ã‚±ãƒ¼ãƒ«ã‚’èª¿æ•´
        fujiModel.setAttribute('scale', `${finalScale} ${finalScale} ${finalScale}`);
    }
    
    // æƒ…å ±è¡¨ç¤ºã‚’æ›´æ–°
    infoDiv.innerHTML = ` 
        ğŸ—» <strong>å¯Œå£«å±±AR</strong><br> 
        <br> 
        ğŸ“ ç¾åœ¨åœ°<br> 
        ã€€ç·¯åº¦: ${userLat.toFixed(6)}<br> 
        ã€€çµŒåº¦: ${userLon.toFixed(6)}<br> 
        <br> 
        ğŸ¯ å¯Œå£«å±±<br> 
        ã€€è·é›¢: <strong>${distance.toFixed(1)}km</strong><br> 
        ã€€æ–¹è§’: <strong>${direction}</strong> (${bearing.toFixed(0)}Â°)<br> 
        <br> 
        ğŸ‘€ **å¯Œå£«å±±ã¯${direction}ã«ã‚ã‚Šã¾ã™**<br> 
        ã€€ãƒ‡ãƒã‚¤ã‚¹ã‚’${direction}ã«å‘ã‘ã¦æ¢ã—ã¦ãã ã•ã„ï¼ 
    `; 
} 

// --- ä½ç½®æƒ…å ±ã®ç›£è¦–ã¨åˆæœŸåŒ– (ç¶­æŒ) ---
if (navigator.geolocation) { 
    navigator.geolocation.watchPosition( 
        (position) => { 
            userLat = position.coords.latitude; 
            userLon = position.coords.longitude; 
            updatePositions(); 
        }, 
        (error) => { 
            const errorMessage = (error.code === 1) ? "ä½ç½®æƒ…å ±ã®åˆ©ç”¨ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚" : `ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰: ${error.code} - ${error.message}`;
            infoDiv.innerHTML = `âŒ ä½ç½®æƒ…å ±ã‚¨ãƒ©ãƒ¼: ${errorMessage}<br><br>è¨­å®šã‹ã‚‰ä½ç½®æƒ…å ±ã‚’è¨±å¯ã—ã¦ãã ã•ã„`; 
            fujisanContainer.setAttribute('visible', false);
        },
        { 
            enableHighAccuracy: true, 
            maximumAge: 0, 
            timeout: 5000 
        } 
    ); 
} else {
    infoDiv.innerHTML = `âŒ ãƒ–ãƒ©ã‚¦ã‚¶ã‚¨ãƒ©ãƒ¼: Geolocation APIã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚`;
}

document.querySelector('a-scene').addEventListener('loaded', () => { 
    console.log('âœ… AR Scene loaded successfully'); 
    setTimeout(updatePositions, 1000); 
}); 

setInterval(updatePositions, 2000); 
</script> 

</body> 
</html>
